##事务原子性

###数据库中的缓存db_buffer、持久化文件data file
###日志的缓存log_buffer、日志持久化log file

### WAL
一个事务进行。刷到缓存log buffer,进行日志存储(UNDO和REDO)到log file，接着再然后写入db buffer，如果db buffer，最后再由db buffer选择策略写入到Log file。这样就就叫坐预写日志(write ahead log)。

如果log buffer的数量为1，能够保证数据的一致性。一旦有数据就进行持久化。但是如果是多个的话，当出现故障的话，会导致log buffer丢失和data buffer丢失，导致数据无法恢复。不过这种能够提高io吞吐量

### Postgres的导入与导出
    导入：psql -U postgres -p 5432 -d ott-cms -1(数字1) -f xx.sql
    由于之前没有加上-1，导致当执行某一句出错的时候，并没有进行回滚，使用了-1保证一个事务
    问题：导入会出现client的gbk字符集无法正常导入(明明服务端的编码是utf-8，文件也是utf-8)。
    原因：可使用psql进入命令行，show client_encoding的字符集，然后使用了set client_encoding to 'utf8'来设置编码
    问题：文件用ue保存为utf-8，但是却一直导入错误
    原因：大文件使用了utf-16进行保存，可以将其转为utf-8（必须是无bom，bom的前三个字节为efbbbf） 
    导出：使用pg_dump -U xxx -p xxx -n schema -d 数据库 -t 表 --inserts -a（必须加上-a，才是只有数据，没有结构）